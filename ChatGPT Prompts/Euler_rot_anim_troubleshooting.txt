# Import Relevant Libraries
import numpy as np
import matplotlib.pyplot as plt

from ipywidgets import interact, FloatSlider 

import plotly.graph_objects as go
from plotly.offline import init_notebook_mode, iplot

'''
The definitions of Rotation Matrices
--------------------------------------------------------------------------------------------------------------------------------------------------------
    - The rotation abt the 1st principle axis (x-axis) is defined by the angle 'psi'
    - The rotation abt the 2nd principle axis (y-axis) is defined by the angle 'theta'
    - The rotation abt the 3rd principle axis (z-axis) is defined by the angle 'phi'
'''

def rotation_matrix_x(phi):
    """Generate rotation matrix for a roll (rotation about the x-axis)"""
    phi = np.radians(phi)
    c, s = np.cos(phi), np.sin(phi)
    return np.array([[1, 0, 0], 
                     [0, c, -s], 
                     [0, s, c]])

def rotation_matrix_y(theta):
    """Generate rotation matrix for a pitch (rotation about the y-axis)"""
    theta = np.radians(theta)
    c, s = np.cos(theta), np.sin(theta)
    return np.array([[c, 0, s], 
                     [0, 1, 0], 
                     [-s, 0, c]])

def rotation_matrix_z(psi):
    """Generate rotation matrix for a yaw (rotation about the z-axis)"""
    psi = np.radians(psi)
    c, s = np.cos(psi), np.sin(psi)
    return np.array([[c, -s, 0], 
                     [s, c, 0], 
                     [0, 0, 1]])

def initialize_frame(fig, frame_matrix, frame_label, colors, is_static=False):
    """
    Initializes vectors on the provided figure as either static or dynamic using a color dictionary.

    Args:
        fig (plotly.graph_objects.Figure) : The figure on which to add the frames.
        frame_matrix (np.ndarray)         : The matrix representing the orientation of the frame.
        frame_label (str)                 : Base label for the frame vectors ('N' for N-frame, 'E' for E-frame).
        colors (dict)                     : Dictionary of colors for each vector, keyed by 'i', 'j', 'k'.
        is_static (bool)                  : Indicates whether the frame should be added as static (with dotted lines).
        
    Note:
    - This function modifies the 'fig' (Figure object) directly. 
      In Python, objects like lists, dictionaries, and classes such as plotly.graph_objects.Figure are mutable. 
      This means they can be changed after creation. 
      `initialize_frame` leverages this by adding traces directly to 'fig', thus altering its state without the need to return a new object.
    
    - The function operates with a side effect: it changes the state of 'fig' by adding traces. 
      It does not return a value because its primary purpose is to modify the existing figure, not produce a new output. 
      This approach avoids the need for managing a return value, simplifying its usage and integration into other parts of your code.
    
    - By not returning a value, it is evident that the function's sole responsibility is to modify the provided figure, 
      aligning with typical practices in Plotly where in-place modifications are common for updating visual properties.

    """
    
    line_style = 'dot' if is_static else 'solid'
    
    suffix = " (static)" if is_static else ""
    
    axis_labels = ['i', 'j', 'k']  # Axis labels corresponding to 'i', 'j', 'k'

    for i, axis in enumerate(axis_labels):
        vec = frame_matrix[:, i]
        name = f'{frame_label}_{axis}{suffix}'
        color = colors[axis]  # Access color using axis label as key
        fig.add_trace(go.Scatter3d(x=[0, vec[0]], 
                                   y=[0, vec[1]], 
                                   z=[0, vec[2]],
                                   mode='lines+markers', 
                                   name=name,
                                   marker=dict(color=color),
                                   line=dict(dash=line_style, color=color)))

def apply_rotations(rotation_sequence, target_angles, steps):
    """
    Generates rotation matrices and applies them to an initial frame.

    Args:
        rotation_sequence (str): The sequence of axes to rotate around (e.g., '321' for Z, Y, X).
        target_angles (dict): Dictionary of target angles in degrees for each axis.
        steps (int): Total number of steps in the animation.

    Returns:
        list: A list of rotation matrices corresponding to each step in the animation.

     Note:
    - Gradual Application: This function doesn't apply the full target rotation all at once but spreads it evenly across the specified number of steps. 
                           This is crucial for creating smooth animations where the transition from the initial to final orientation feels seamless.
    
    - Order of Operations: The rotations are applied in the order specified by `rotation_sequence`. 
                           Understanding the order is important because rotation operations are not commutative; 
                           the outcome depends on the order in which rotations are applied.
    
    - Efficient Matrix Operations: Each step involves matrix multiplication, which is computationally intensive. 
                                   The function optimizes this by computing only the necessary rotations at each step, avoiding redundant calculations.
    
    - Identity Matrix Initialization: Each new rotation calculation starts with an identity matrix, representing a no-rotation state. 
                                      The rotation matrices are built incrementally from this starting point, 
                                      ensuring that each frame's matrix is correctly derived from a neutral orientation.
    
    - Loop Exit Conditions: The loop that applies rotations checks if the cumulative steps have reached or exceeded the steps allotted to 
                            the current rotation before continuing. 
                            This ensures that each axis rotation completes precisely within its segment of the total animation steps.
    """
    # Calculate the number of steps for each rotation based on the total number of steps and the length of the rotation sequence
    steps_per_rotation = steps // len(rotation_sequence)

    # Map each axis identifier ('1', '2', '3') to the corresponding rotation function
    rotation_functions = {'1': rotation_matrix_x, 
                          '2': rotation_matrix_y, 
                          '3': rotation_matrix_z}

    # Initialize a list to store the rotation matrices for each step (frame of animation)
    rotation_matrices = []

    # Current angle for each axis
    current_angle = {k: 0 for k in rotation_functions.keys()}  
    
    # Iterate through each animation frame to calculate the rotation matrix
    for frame in range(steps + 1):
        
        # Start with the identity matrix (no rotation)
        R = np.eye(3)
        
        cumulative_steps = 0  # This will track the total number of steps taken up to the current part of the rotation sequence

        # Loop through each axis in the rotation sequence to apply the rotations
        for axis in rotation_sequence:
            
            # Calculate how many steps have been taken for the current axis
            axis_steps = frame - cumulative_steps
            if axis_steps > steps_per_rotation:
                axis_steps = steps_per_rotation

            # Determine the proportion of the full rotation to apply at the current frame
            progress = axis_steps / steps_per_rotation if steps_per_rotation else 0
            angle_deg = progress * target_angles[axis]  # Calculate the actual angle to rotate at this frame

            # Update the rotation matrix by multiplying it by the rotation matrix for the current axis
            R = np.matmul(R, rotation_functions[axis](angle_deg))

            # Update the count of cumulative steps
            cumulative_steps += steps_per_rotation

            # If the current frame completes the rotation for the current axis, exit the loop
            if frame < cumulative_steps:
                break

        # Append the calculated rotation matrix for the current frame to the list
        rotation_matrices.append(R)
    
    return rotation_matrices

def setup_animation_controls(fig, frames):
    """
    Adds animation controls and configures layout settings for a Plotly figure.

    Args:
        fig (plotly.graph_objects.Figure): The figure to which the controls will be added.
        frames (list): List of animation frames to be included in the slider control.

    Note:
    - Animation Controls: This function sets up interactive controls that allow users to play through or step through the animation frames at their own pace. 
                          The 'Play' button starts the animation, while the slider allows users to jump to specific points in the animation.
    
    - Button Configuration: The 'Play' button is configured to start the animation immediately when clicked, using the 'immediate' mode. 
                            It ensures that the animation runs smoothly, redrawing each frame with a duration of 100 milliseconds.
    
    - Slider Mechanism: The slider below the animation includes steps corresponding to each frame created in the animation sequence. 
                        Users can move the slider to navigate to different frames, which is particularly useful for examining specific moments of the animation in detail.
    
    - Current Value Display: The slider also shows the current frame number as the animation plays, 
                             providing immediate visual feedback to users on their current position within the animation sequence.
    
    - Layout Configuration: The function also defines the visual layout of the 3D scene. 
                            It sets a fixed cube aspect for the axes to ensure that objects in the 3D space are displayed proportionally. 
                            The axes are configured to not auto-scale, maintaining consistent spatial references.
    
    - Scene Dimensions: The overall dimensions of the figure are set to ensure sufficient space for viewing the animation comfortably, enhancing the visual experience for the user.
    
    - Usability and Interactivity: By integrating these controls, the function enhances the usability and interactivity of the visualization, 
                                   making it a more effective tool for presentations or educational purposes where step-by-step analysis of movements is beneficial.

    """
    # Update the figure with animation controls
    fig.update_layout(updatemenus=[{"type": "buttons",
                                    "showactive": False,
                                    "y": 1.05,
                                    "x": 0.8,
                                    "xanchor": 'left',
                                    "yanchor": 'bottom',
                                    "buttons": [{"label": 'Play',
                                                 "method": 'animate',
                                                 "args": [None, {"frame": {"duration": 100, "redraw": True},
                                                                 "fromcurrent": True,
                                                                 "mode": 'immediate'}]}]}],
                      sliders=[{"steps": [{"method": 'animate',
                                           "args": [[f.name], {"mode": 'immediate', 
                                                               "frame": {"duration": 100, "redraw": True},
                                                               "fromcurrent": True}],
                                           "label": str(k)} for k, f in enumerate(frames)],
                                "x": 0.1,
                                "y": 0,
                                "currentvalue": {"visible": True, "prefix": 'Step: '}}])

    # Set additional layout settings for the 3D scene
    fig.update_layout(width=1000,
                      height=800,
                      template='presentation',
                      scene={"aspectmode": 'cube',
                             "xaxis": {"range": [-1, 1], "autorange": False},
                             "yaxis": {"range": [-1, 1], "autorange": False},
                             "zaxis": {"range": [-1, 1], "autorange": False}},
                      title='Euler Rotation Animation')

def set_small_to_zero(matrix, threshold=1e-10):
    """
    Sets elements of the matrix that are close to zero to exactly zero.
    
    Args:
    matrix (np.ndarray) : The input matrix with small values close to zero.
    threshold (float)   : A threshold value to determine "closeness" to zero.
    
    Returns:
    np.ndarray: The modified matrix with values close to zero set to exactly zero.

    Note:
    - Floating-Point Precision: In numerical computations, especially with floating-point arithmetic, 
                                operations can result in very small numbers close to zero (e.g., 4e-17) instead of exact zeros. 
                                This is due to the inherent limitations in the precision of floating-point representations, 
                                which cannot exactly represent all real numbers.

    - Numerical Stability: These small but non-zero numbers can affect the stability and accuracy of numerical algorithms, 
                           especially those that expect true zero values. 
                           Setting these values to zero can help in preventing unexpected behavior in such computations.

    - Threshold Determination: The threshold for considering a value "close enough" to zero is adjustable, 
                               allowing users to define what is practically zero in the context of their specific application. 
                               This flexibility is crucial for tailoring the function to different numerical precision requirements.

    - In-place Modification: The function modifies the matrix in-place for efficiency, directly altering the input matrix. 
                             Users should be aware that the original data will be changed.
    """
    matrix[np.abs(matrix) < threshold] = 0
    return matrix

def euler_rotation_animation(rotation_sequence, target_1st_rot_deg, target_2nd_rot_deg, target_3rd_rot_deg, steps=30):
    '''
    Creates a 3D animation of Euler rotations with the specified sequence and angles and prints out the matrix of final orientation of the frame.
    
    Args:
        rotation_sequence (str)    : A string representing the desired rotation sequence (e.g., "123" for ZYX).
        target_1st_rot_deg (float) : The magnitude of the 1st rotation angle about the defined axis (if sequence is 123, it is rotation about axis 1).
        target_2nd_rot_deg (float) : The magnitude of the 2nd rotation angle about the defined axis (if sequence is 123, it is rotation about axis 2).
        target_3rd_rot_deg (float) : The magnitude of the 3rd rotation angle about the defined axis (if sequence is 123, it is rotation about axis 3).
        steps (int, optional)      : The total number of steps in the animation. Defaults to 30.
        
    Returns:
        plotly.graph_objects.Figure: The figure object containing the animation.

    Note:
    - Dynamic Frame Calculation: This function handles the creation of a 3D Euler rotation animation by dynamically calculating rotation matrices 
                                 for each step and applying these to an initial orientation matrix. 
                                 It visually represents these orientations in a Plotly figure.

    - Identity Matrix Use: It starts with an identity matrix, representing no rotation, as a baseline to which incremental rotations are applied. 
                           This approach helps in visualizing the rotation from a starting point of zero rotation.
    
    - Color Mapping: Colors are mapped to axes based on a predefined dictionary, enhancing the visual distinction of different axes in the animation.

    - In-place Frame Updates: The function updates the figure object in-place with animation frames, 
                              leveraging Plotly's capabilities to handle complex animations efficiently.

    - Print Statement: After completing the rotations, the function prints the final orientation matrix, 
                       converted to zero where values are negligibly small, providing a clean, readable output for final orientation verification.
    '''
     # Initialize the figure for 3D visualization
    fig = go.Figure()

    # Create the identity matrix representing the initial orientation of the frame
    N_frame = np.eye(3)

    # Dictiornary of colors specifying colors of axes
    colors = {'i': 'red', 
              'j': 'green', 
              'k': 'blue'}

    # List to define axis labels for ease of understanding and to avoid ASCII manipulation
    axis_labels = ['i', 'j', 'k']

    # Initialize the static N-frame
    initialize_frame(fig, N_frame, 'N', colors, is_static=True)

    # Initialize the dynamic E-frame
    initialize_frame(fig, N_frame, 'E', colors, is_static=False)

    # Compute rotation matrix of each frame
    target_angles = {'1': target_1st_rot_deg, 
                     '2': target_2nd_rot_deg, 
                     '3': target_3rd_rot_deg}
    
    rotation_matrices = apply_rotations(rotation_sequence, target_angles, steps)

    frames = []
    for i, R in enumerate(rotation_matrices):
        E_frame = np.dot(R, N_frame.T)
        frame_data = [go.Scatter3d(x=[0, vec[0]], 
                                   y=[0, vec[1]], 
                                   z=[0, vec[2]],
                                   mode='lines+markers', 
                                   name=f'E_{chr(105+j)}',
                                   marker=dict(color=colors[axis_labels[j]])) for j, vec in enumerate(E_frame.T)]
        
        frames.append(go.Frame(data=frame_data, name=str(i), traces=list(range(3, 6))))
    
    # Configure the figure with the generated frames
    fig.frames = frames

    # Set small values to zero
    cleaned_E_matrix = set_small_to_zero(E_frame)
    print(f'Final E-Frame Orientation:\n{np.matrix(cleaned_E_matrix)}')
    
    setup_animation_controls(fig, frames)

    return fig

fig = euler_rotation_animation('313', 90, 45, 90)
iplot(fig)