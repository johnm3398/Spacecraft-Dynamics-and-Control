def initialize_ref_frame(fig, frame_matrix, frame_label, colors, is_static=False):
    """
    Initializes vectors on the provided figure as either static or dynamic using a color dictionary.

    Args:
        fig (plotly.graph_objects.Figure) : The figure on which to add the frames.
        frame_matrix (np.ndarray)         : The matrix representing the orientation of the frame.
        frame_label (str)                 : Base label for the frame vectors ('N' for N-frame, 'E' for E-frame).
        colors (dict)                     : Dictionary of colors for each vector, keyed by 'i', 'j', 'k'.
        is_static (bool)                  : Indicates whether the frame should be added as static (with dotted lines).
        
    Note:
    - This function modifies the 'fig' (Figure object) directly. 
      In Python, objects like lists, dictionaries, and classes such as plotly.graph_objects.Figure are mutable. 
      This means they can be changed after creation. 
      `initialize_ref_frame` leverages this by adding traces directly to 'fig', thus altering its state without the need to return a new object.
    
    - The function operates with a side effect: it changes the state of 'fig' by adding traces. 
      It does not return a value because its primary purpose is to modify the existing figure, not produce a new output. 
      This approach avoids the need for managing a return value, simplifying its usage and integration into other parts of your code.
    
    - By not returning a value, it is evident that the function's sole responsibility is to modify the provided figure, 
      aligning with typical practices in Plotly where in-place modifications are common for updating visual properties.

    """
    
    line_style = 'dot' if is_static else 'solid'
    
    suffix = " (static)" if is_static else ""
    
    axis_labels = ['i', 'j', 'k']  # Axis labels corresponding to 'i', 'j', 'k'

    for i, axis in enumerate(axis_labels):
        vec = frame_matrix[:, i]
        name = f'{frame_label}_{axis}{suffix}'
        color = colors[axis]  # Access color using axis label as key
        fig.add_trace(go.Scatter3d(x=[0, vec[0]], 
                                   y=[0, vec[1]], 
                                   z=[0, vec[2]],
                                   mode='lines+markers', 
                                   name=name,
                                   marker=dict(color=color),
                                   line=dict(dash=line_style, color=color)))

def apply_rotations(rotation_sequence, target_angles, steps):
    """
    Generates rotation matrices and applies them to an initial frame, based on a specified rotation sequence and corresponding angles.

    Args:
        rotation_sequence (str): The sequence of axes to rotate around, specified as characters (e.g., '321' for rotations around Z, Y, X axes).
        target_angles (tuple): Tuple of target angles in degrees, each element corresponding to the rotation about the axis in the rotation_sequence.
        steps (int): Total number of steps in the animation, dictating the granularity of the rotation application.

    Returns:
        list: A list of rotation matrices corresponding to each step in the animation, representing the frame's orientation at each step.

    Notes:
    - Gradual Application: Rotations are not applied abruptly but are instead distributed evenly across the specified number of steps, 
      facilitating a smooth transition from the initial orientation to the final desired orientation. This gradual approach mimics realistic motion dynamics.

    - Order of Operations: The function adheres strictly to the specified order of rotations, which is critical because the outcome of rotation sequences
      is dependent on the order due to the non-commutative nature of rotation operations. 

    - Efficiency in Computation: To optimize performance, especially important in computationally intensive applications like animations, 
      the function calculates only the necessary rotation at each step instead of recalculating the entire sequence, thereby reducing computational overhead.

    - Initialization and Incremental Building: The process begins with an identity matrix, symbolizing a no-rotation state, and incrementally applies transformations. 
      This method ensures that each step's matrix accurately builds upon the previous, reflecting cumulative rotations.

    - Controlled Execution Flow: The execution within the loop is carefully controlled to ensure that each axis's rotation completes within its allotted segment 
      of the total steps, preventing overrun and ensuring precise adherence to the intended motion path.

    This updated methodology accommodates sequences with repeated axes, where each occurrence of an axis can have a distinct rotation angle, enhancing the function's flexibility and applicability to complex rotational sequences.
    """

    # Calculate the number of frames for each rotation based on the total number of steps and the length of the rotation sequence
    steps_per_rotation = steps // len(rotation_sequence)
     
    # Map each axis identifier ('1', '2', '3') to the corresponding rotation function
    rotation_functions = {'1': rotation_matrix_x, 
                          '2': rotation_matrix_y, 
                          '3': rotation_matrix_z}

    # Initialize a list to store the rotation matrices for each step
    rotation_matrices = []
    
    #print(target_angles)
    
    # Iterate through each animation frame to calculate the rotation matrix
    for frame in range(steps + 1):
        
        # Start with the identity matrix (no rotation)
        R = np.eye(3)
        
        cumulative_steps = 0  # This will track the total number of steps taken up to the current part of the rotation sequence

        # Loop through each axis in the rotation sequence to apply the rotations
        for index, axis in enumerate(rotation_sequence):
            
            # Calculate how many steps have been taken for the current axis
            axis_steps = frame - cumulative_steps
            if axis_steps > steps_per_rotation:
                axis_steps = steps_per_rotation

            # Determine the proportion of the full rotation to apply at the current frame
            progress = axis_steps / steps_per_rotation if steps_per_rotation else 0
            angle_deg = progress * target_angles[index]  # Use index to access the corresponding angle from the tuple

            # Apply the new rotation matrix to the current rotation state. The order of multiplication
            # is chosen to ensure that the latest rotation is applied directly to the initial frame,
            # with the previously accumulated rotations (R) applied afterwards, maintaining the correct
            # sequence as per the rotation sequence and right-handed coordinate system convention.
            R = np.matmul(rotation_functions[axis](angle_deg), R)

            # Update the count of cumulative steps
            cumulative_steps += steps_per_rotation

            # If the current frame completes the rotation for the current axis, exit the loop
            if frame < cumulative_steps:
                break

        # Append the calculated rotation matrix for the current frame to the list
        # Note: Rotation Matrics are Row-Major
        rotation_matrices.append(R)
    
    #print(rotation_matrices[-1])
    
    return rotation_matrices

def setup_animation_scene(fig, frames, title):
    """
    Adds animation controls and configures layout settings for a Plotly figure.

    Args:
        fig (plotly.graph_objects.Figure): The figure to which the controls will be added.
        frames (list): List of animation frames to be included in the slider control.
        title (str): The title to set for the animation scene.

    Note:
    - Animation Controls: This function sets up interactive controls that allow users to play through or step through the animation frames at their own pace. 
                          The 'Play' button starts the animation, while the slider allows users to jump to specific points in the animation.
    
    - Button Configuration: The 'Play' button is configured to start the animation immediately when clicked, using the 'immediate' mode. 
                            It ensures that the animation runs smoothly, redrawing each frame with a duration of 100 milliseconds.
    
    - Slider Mechanism: The slider below the animation includes steps corresponding to each frame created in the animation sequence. 
                        Users can move the slider to navigate to different frames, which is particularly useful for examining specific moments of the animation in detail.
    
    - Current Value Display: The slider also shows the current frame number as the animation plays, 
                             providing immediate visual feedback to users on their current position within the animation sequence.
    
    - Layout Configuration: The function also defines the visual layout of the 3D scene. 
                            It sets a fixed cube aspect for the axes to ensure that objects in the 3D space are displayed proportionally. 
                            The axes are configured to not auto-scale, maintaining consistent spatial references.
    
    - Scene Dimensions: The overall dimensions of the figure are set to ensure sufficient space for viewing the animation comfortably, enhancing the visual experience for the user.
    
    - Usability and Interactivity: By integrating these controls, the function enhances the usability and interactivity of the visualization, 
                                   making it a more effective tool for presentations or educational purposes where step-by-step analysis of movements is beneficial.

    """
    # Update the figure with animation controls
    fig.update_layout(updatemenus=[{"type": "buttons",
                                    "showactive": False,
                                    "y": -0.13,
                                    "x": -0.02,
                                    "xanchor": 'left',
                                    "yanchor": 'bottom',
                                    "buttons": [{"label": 'Play',
                                                 "method": 'animate',
                                                 "args": [None, {"frame": {"duration": 100, "redraw": True},
                                                                 "fromcurrent": True,
                                                                 "mode": 'immediate'}]}]}],
                      sliders=[{"steps": [{"method": 'animate',
                                           "args": [[f.name], {"mode": 'immediate', 
                                                               "frame": {"duration": 100, "redraw": True},
                                                               "fromcurrent": True}],
                                           "label": str(k)} for k, f in enumerate(frames)],
                                "x": 0.1,
                                "y": 0,
                                "currentvalue": {"visible": True, "prefix": 'Step: '}}])

    # Set additional layout settings for the 3D scene
    fig.update_layout(width=1000,
                      height=800,
                      template='presentation',
                      scene={"aspectmode": 'cube',
                             "xaxis": {"range": [-1, 1], "autorange": False},
                             "yaxis": {"range": [-1, 1], "autorange": False},
                             "zaxis": {"range": [-1, 1], "autorange": False}},
                      title=f"{title}")

def set_small_to_zero(matrix, threshold=1e-10):
    """
    Sets elements of the matrix that are close to zero to exactly zero.
    
    Args:
    matrix (np.ndarray) : The input matrix with small values close to zero.
    threshold (float)   : A threshold value to determine "closeness" to zero.
    
    Returns:
    np.ndarray: The modified matrix with values close to zero set to exactly zero.

    Note:
    - Floating-Point Precision: In numerical computations, especially with floating-point arithmetic, 
                                operations can result in very small numbers close to zero (e.g., 4e-17) instead of exact zeros. 
                                This is due to the inherent limitations in the precision of floating-point representations, 
                                which cannot exactly represent all real numbers.

    - Numerical Stability: These small but non-zero numbers can affect the stability and accuracy of numerical algorithms, 
                           especially those that expect true zero values. 
                           Setting these values to zero can help in preventing unexpected behavior in such computations.

    - Threshold Determination: The threshold for considering a value "close enough" to zero is adjustable, 
                               allowing users to define what is practically zero in the context of their specific application. 
                               This flexibility is crucial for tailoring the function to different numerical precision requirements.

    - In-place Modification: The function modifies the matrix in-place for efficiency, directly altering the input matrix. 
                             Users should be aware that the original data will be changed.
    """
    matrix[np.abs(matrix) < threshold] = 0
    return matrix

def euler_rotation_animation(rotation_sequence, target_angles_tuple, steps=30):
    '''
    Creates a 3D animation of Euler rotations based on a specified sequence and corresponding angles, and displays the final orientation of the frame.

    Args:
        rotation_sequence (str): A string representing the desired rotation sequence (e.g., "123" for ZYX).
        target_angles (tuple): A tuple containing 3 angles in degrees for each rotation specified in the rotation sequence.
        steps (int, optional): The total number of steps in the animation. Defaults to 30.
        
    Returns:
        plotly.graph_objects.Figure: The figure object containing the animation.

    Notes:
    - Dynamic Frame Calculation: This function dynamically calculates rotation matrices for each step based on the rotation sequence and target angles,
      applying these to an initial orientation matrix to visually represent these orientations in a Plotly figure.
    
    - Identity Matrix Use: Begins with an identity matrix as a baseline to which incremental rotations are applied, aiding in visualizing the rotation from a no-rotation state.
    
    - Color Mapping: Utilizes a predefined color dictionary to enhance the visual distinction of different axes in the animation.
    
    - In-place Frame Updates: Updates the figure object in-place with animation frames, utilizing Plotly's capabilities to manage complex animations efficiently.
    
    - Print Statement: Outputs the final orientation matrix, setting small values to zero for a clean, readable display of the final orientation.
    '''
     # Initialize the figure for 3D visualization
    fig = go.Figure()

    # Create the identity matrix representing the initial orientation of the frame
    N_frame = np.eye(3)

    # Dictiornary of colors specifying colors of axes
    colors = {'i': 'red', 
              'j': 'green', 
              'k': 'blue'}

    # List to define axis labels for ease of understanding and to avoid ASCII manipulation
    axis_labels = ['i', 'j', 'k']

    # Initialize the static N-frame
    initialize_ref_frame(fig, N_frame, 'N', colors, is_static=True)

    # Initialize the dynamic E-frame
    initialize_ref_frame(fig, N_frame, 'E', colors, is_static=False)

    rotation_matrices = apply_rotations(rotation_sequence, target_angles_tuple, steps)

    frames = []
    for i, R in enumerate(rotation_matrices):
        E_frame = np.matmul(R, N_frame)
        frame_data = [go.Scatter3d(x=[0, vec[0]], 
                                   y=[0, vec[1]], 
                                   z=[0, vec[2]],
                                   mode='lines+markers', 
                                   name=f'E_{chr(105+j)}',
                                   marker=dict(color=colors[axis_labels[j]])) for j, vec in enumerate(E_frame)]
        
        frames.append(go.Frame(data=frame_data, name=str(i), traces=[3, 4, 5]))
    
    # Configure the figure with the generated frames
    fig.frames = frames

    # Set small values to zero
    cleaned_E_matrix = set_small_to_zero(E_frame)
    print(f'Final E-Frame Orientation:\n{np.matrix(cleaned_E_matrix)}')
    
    setup_animation_scene(fig, frames, "Euler Angles Rotation Animated")

    return fig